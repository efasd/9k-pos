import { __decorate, __metadata } from "tslib";
import { Component, Input, SimpleChanges, ViewEncapsulation, Renderer2, AfterViewInit, ElementRef, OnChanges, OnDestroy, ViewChild, ContentChild } from '@angular/core';
import { clamp, coerceBooleanProperty, coerceNumberProperty, cssUnit, isNumber } from '../common/util';
import { NgxGaugeLabel, NgxGaugeValue, NgxGaugePrepend, NgxGaugeAppend } from './gauge-directives';
var DEFAULTS = {
    MIN: 0,
    MAX: 100,
    TYPE: 'arch',
    THICK: 4,
    FOREGROUND_COLOR: 'rgba(0, 150, 136, 1)',
    BACKGROUND_COLOR: 'rgba(0, 0, 0, 0.1)',
    CAP: 'butt',
    SIZE: 200
};
var NgxGauge = /** @class */ (function () {
    function NgxGauge(_elementRef, _renderer) {
        this._elementRef = _elementRef;
        this._renderer = _renderer;
        this._size = DEFAULTS.SIZE;
        this._min = DEFAULTS.MIN;
        this._max = DEFAULTS.MAX;
        this._animate = true;
        this._initialized = false;
        this._animationRequestID = 0;
        this.ariaLabel = '';
        this.ariaLabelledby = null;
        this.type = DEFAULTS.TYPE;
        this.cap = DEFAULTS.CAP;
        this.thick = DEFAULTS.THICK;
        this.foregroundColor = DEFAULTS.FOREGROUND_COLOR;
        this.backgroundColor = DEFAULTS.BACKGROUND_COLOR;
        this.thresholds = Object.create(null);
        this._value = 0;
        this.duration = 1200;
    }
    Object.defineProperty(NgxGauge.prototype, "size", {
        get: function () { return this._size; },
        set: function (value) {
            this._size = coerceNumberProperty(value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NgxGauge.prototype, "min", {
        get: function () { return this._min; },
        set: function (value) {
            this._min = coerceNumberProperty(value, DEFAULTS.MIN);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NgxGauge.prototype, "animate", {
        get: function () { return this._animate; },
        set: function (value) {
            this._animate = coerceBooleanProperty(value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NgxGauge.prototype, "max", {
        get: function () { return this._max; },
        set: function (value) {
            this._max = coerceNumberProperty(value, DEFAULTS.MAX);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NgxGauge.prototype, "value", {
        get: function () { return this._value; },
        set: function (val) {
            this._value = coerceNumberProperty(val);
        },
        enumerable: true,
        configurable: true
    });
    NgxGauge.prototype.ngOnChanges = function (changes) {
        var isCanvasPropertyChanged = changes['thick'] || changes['type'] || changes['cap'] || changes['size'];
        var isDataChanged = changes['value'] || changes['min'] || changes['max'];
        if (this._initialized) {
            if (isDataChanged) {
                var nv = void 0, ov = void 0;
                if (changes['value']) {
                    nv = changes['value'].currentValue;
                    ov = changes['value'].previousValue;
                }
                this._update(nv, ov);
            }
            if (isCanvasPropertyChanged) {
                this._destroy();
                this._init();
            }
        }
    };
    NgxGauge.prototype._updateSize = function () {
        this._renderer.setStyle(this._elementRef.nativeElement, 'width', cssUnit(this._getWidth()));
        this._renderer.setStyle(this._elementRef.nativeElement, 'height', cssUnit(this._getCanvasHeight()));
        this._canvas.nativeElement.width = this._getWidth();
        this._canvas.nativeElement.height = this._getCanvasHeight();
        this._renderer.setStyle(this._label.nativeElement, 'transform', 'translateY(' + (this.size / 3 * 2 - this.size / 13 / 4) + 'px)');
        this._renderer.setStyle(this._reading.nativeElement, 'transform', 'translateY(' + (this.size / 2 - this.size * 0.22 / 2) + 'px)');
    };
    NgxGauge.prototype.ngAfterViewInit = function () {
        if (this._canvas) {
            this._init();
        }
    };
    NgxGauge.prototype.ngOnDestroy = function () {
        this._destroy();
    };
    NgxGauge.prototype._getBounds = function (type) {
        var head, tail;
        if (type == 'semi') {
            head = Math.PI;
            tail = 2 * Math.PI;
        }
        else if (type == 'full') {
            head = 1.5 * Math.PI;
            tail = 3.5 * Math.PI;
        }
        else if (type === 'arch') {
            head = 0.8 * Math.PI;
            tail = 2.2 * Math.PI;
        }
        return { head: head, tail: tail };
    };
    NgxGauge.prototype._drawShell = function (start, middle, tail, color) {
        var center = this._getCenter(), radius = this._getRadius();
        middle = Math.max(middle, start); // never below 0%
        middle = Math.min(middle, tail); // never exceed 100%
        if (this._initialized) {
            this._clear();
            this._context.beginPath();
            this._context.strokeStyle = this.backgroundColor;
            this._context.arc(center.x, center.y, radius, middle, tail, false);
            this._context.stroke();
            this._context.beginPath();
            this._context.strokeStyle = color;
            this._context.arc(center.x, center.y, radius, start, middle, false);
            this._context.stroke();
        }
    };
    NgxGauge.prototype._clear = function () {
        this._context.clearRect(0, 0, this._getWidth(), this._getHeight());
    };
    NgxGauge.prototype._getWidth = function () {
        return this.size;
    };
    NgxGauge.prototype._getHeight = function () {
        return this.size;
    };
    // canvas height will be shorter for type 'semi' and 'arch'
    NgxGauge.prototype._getCanvasHeight = function () {
        return (this.type == 'arch' || this.type == 'semi')
            ? 0.85 * this._getHeight()
            : this._getHeight();
    };
    NgxGauge.prototype._getRadius = function () {
        var center = this._getCenter();
        return center.x - this.thick;
    };
    NgxGauge.prototype._getCenter = function () {
        var x = this._getWidth() / 2, y = this._getHeight() / 2;
        return { x: x, y: y };
    };
    NgxGauge.prototype._init = function () {
        this._context = this._canvas.nativeElement.getContext('2d');
        this._initialized = true;
        this._updateSize();
        this._setupStyles();
        this._create();
    };
    NgxGauge.prototype._destroy = function () {
        if (this._animationRequestID) {
            window.cancelAnimationFrame(this._animationRequestID);
            this._animationRequestID = 0;
        }
        this._clear();
        this._context = null;
        this._initialized = false;
    };
    NgxGauge.prototype._setupStyles = function () {
        this._context.lineCap = this.cap;
        this._context.lineWidth = this.thick;
    };
    NgxGauge.prototype._getForegroundColorByRange = function (value) {
        var match = Object.keys(this.thresholds)
            .filter(function (item) { return isNumber(item) && Number(item) <= value; })
            .sort(function (a, b) { return Number(a) - Number(b); })
            .reverse()[0];
        return match !== undefined
            ? this.thresholds[match].color || this.foregroundColor
            : this.foregroundColor;
    };
    NgxGauge.prototype._create = function (nv, ov) {
        var self = this, type = this.type, bounds = this._getBounds(type), duration = this.duration, min = this.min, max = this.max, value = clamp(this.value, this.min, this.max), start = bounds.head, unit = (bounds.tail - bounds.head) / (max - min), displacement = unit * (value - min), tail = bounds.tail, color = this._getForegroundColorByRange(value), startTime;
        if (self._animationRequestID) {
            window.cancelAnimationFrame(self._animationRequestID);
        }
        function animate(timestamp) {
            timestamp = timestamp || new Date().getTime();
            var runtime = timestamp - startTime;
            var progress = Math.min(runtime / duration, 1);
            var previousProgress = ov ? (ov - min) * unit : 0;
            var middle = start + previousProgress + displacement * progress;
            self._drawShell(start, middle, tail, color);
            if (self._animationRequestID && (runtime < duration)) {
                self._animationRequestID = window.requestAnimationFrame(function (timestamp) { return animate(timestamp); });
            }
            else {
                window.cancelAnimationFrame(self._animationRequestID);
            }
        }
        if (this._animate) {
            if (nv != undefined && ov != undefined) {
                displacement = unit * nv - unit * ov;
            }
            self._animationRequestID = window.requestAnimationFrame(function (timestamp) {
                startTime = timestamp || new Date().getTime();
                animate(startTime);
            });
        }
        else {
            self._drawShell(start, start + displacement, tail, color);
        }
    };
    NgxGauge.prototype._update = function (nv, ov) {
        this._clear();
        this._create(nv, ov);
    };
    NgxGauge.ctorParameters = function () { return [
        { type: ElementRef },
        { type: Renderer2 }
    ]; };
    __decorate([
        ViewChild('canvas', { static: true }),
        __metadata("design:type", ElementRef)
    ], NgxGauge.prototype, "_canvas", void 0);
    __decorate([
        ViewChild('rLabel', { static: true }),
        __metadata("design:type", ElementRef)
    ], NgxGauge.prototype, "_label", void 0);
    __decorate([
        ViewChild('reading', { static: true }),
        __metadata("design:type", ElementRef)
    ], NgxGauge.prototype, "_reading", void 0);
    __decorate([
        ContentChild(NgxGaugeLabel),
        __metadata("design:type", NgxGaugeLabel)
    ], NgxGauge.prototype, "_labelChild", void 0);
    __decorate([
        ContentChild(NgxGaugePrepend),
        __metadata("design:type", NgxGaugePrepend)
    ], NgxGauge.prototype, "_prependChild", void 0);
    __decorate([
        ContentChild(NgxGaugeAppend),
        __metadata("design:type", NgxGaugeAppend)
    ], NgxGauge.prototype, "_appendChild", void 0);
    __decorate([
        ContentChild(NgxGaugeValue),
        __metadata("design:type", NgxGaugeValue)
    ], NgxGauge.prototype, "_valueDisplayChild", void 0);
    __decorate([
        Input('aria-label'),
        __metadata("design:type", String)
    ], NgxGauge.prototype, "ariaLabel", void 0);
    __decorate([
        Input('aria-labelledby'),
        __metadata("design:type", String)
    ], NgxGauge.prototype, "ariaLabelledby", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number),
        __metadata("design:paramtypes", [Number])
    ], NgxGauge.prototype, "size", null);
    __decorate([
        Input(),
        __metadata("design:type", Number),
        __metadata("design:paramtypes", [Number])
    ], NgxGauge.prototype, "min", null);
    __decorate([
        Input(),
        __metadata("design:type", Boolean),
        __metadata("design:paramtypes", [Object])
    ], NgxGauge.prototype, "animate", null);
    __decorate([
        Input(),
        __metadata("design:type", Number),
        __metadata("design:paramtypes", [Number])
    ], NgxGauge.prototype, "max", null);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], NgxGauge.prototype, "type", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], NgxGauge.prototype, "cap", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], NgxGauge.prototype, "thick", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], NgxGauge.prototype, "label", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], NgxGauge.prototype, "append", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], NgxGauge.prototype, "prepend", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], NgxGauge.prototype, "foregroundColor", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], NgxGauge.prototype, "backgroundColor", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], NgxGauge.prototype, "thresholds", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number),
        __metadata("design:paramtypes", [Number])
    ], NgxGauge.prototype, "value", null);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], NgxGauge.prototype, "duration", void 0);
    NgxGauge = __decorate([
        Component({
            selector: 'ngx-gauge',
            template: "<div class=\"reading-block\" #reading [style.fontSize]=\"size * 0.22 + 'px'\">\r\n  <!-- This block can not be indented correctly, because line breaks cause layout spacing, related problem: https://pt.stackoverflow.com/q/276760/2998 -->\r\n  <u class=\"reading-affix\" [ngSwitch]=\"_prependChild != null\"><ng-content select=\"ngx-gauge-prepend\" *ngSwitchCase=\"true\"></ng-content><ng-container *ngSwitchCase=\"false\">{{prepend}}</ng-container></u><ng-container [ngSwitch]=\"_valueDisplayChild != null\"><ng-content *ngSwitchCase=\"true\" select=\"ngx-gauge-value\"></ng-content><ng-container *ngSwitchCase=\"false\">{{value | number}}</ng-container></ng-container><u class=\"reading-affix\" [ngSwitch]=\"_appendChild != null\"><ng-content select=\"ngx-gauge-append\" *ngSwitchCase=\"true\"></ng-content><ng-container *ngSwitchCase=\"false\">{{append}}</ng-container></u>\r\n</div>\r\n<div class=\"reading-label\" #rLabel\r\n     [style.fontSize]=\"size / 13 + 'px'\"\r\n     [ngSwitch]=\"_labelChild != null\">\r\n  <ng-content select=\"ngx-gauge-label\" *ngSwitchCase=\"true\"></ng-content>\r\n  <ng-container *ngSwitchCase=\"false\">{{label}}</ng-container>\r\n</div>\r\n<canvas #canvas></canvas>\r\n",
            host: {
                'role': 'slider',
                'aria-readonly': 'true',
                '[class.ngx-gauge-meter]': 'true',
                '[attr.aria-valuemin]': 'min',
                '[attr.aria-valuemax]': 'max',
                '[attr.aria-valuenow]': 'value',
                '[attr.aria-label]': 'ariaLabel',
                '[attr.aria-labelledby]': 'ariaLabelledby'
            },
            encapsulation: ViewEncapsulation.None,
            styles: [".ngx-gauge-meter{display:inline-block;text-align:center;position:relative}.reading-block{position:absolute;width:100%;font-weight:400;white-space:nowrap;text-align:center;overflow:hidden;text-overflow:ellipsis}.reading-label{font-family:inherit;width:100%;display:inline-block;position:absolute;text-align:center;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;font-weight:400}.reading-affix{text-decoration:none;font-size:.6em;opacity:.8;font-weight:200;padding:0 .18em}.reading-affix:first-child{padding-left:0}.reading-affix:last-child{padding-right:0}"]
        }),
        __metadata("design:paramtypes", [ElementRef, Renderer2])
    ], NgxGauge);
    return NgxGauge;
}());
export { NgxGauge };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZ2F1Z2UuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9uZ3gtZ2F1Z2UvIiwic291cmNlcyI6WyJnYXVnZS9nYXVnZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUEsT0FBTyxFQUNILFNBQVMsRUFDVCxLQUFLLEVBQ0wsYUFBYSxFQUNiLGlCQUFpQixFQUNqQixTQUFTLEVBQ1QsYUFBYSxFQUNiLFVBQVUsRUFDVixTQUFTLEVBQ1QsU0FBUyxFQUNULFNBQVMsRUFDVCxZQUFZLEVBQ2YsTUFBTSxlQUFlLENBQUM7QUFFdkIsT0FBTyxFQUNILEtBQUssRUFDTCxxQkFBcUIsRUFDckIsb0JBQW9CLEVBQ3BCLE9BQU8sRUFDUCxRQUFRLEVBQ1gsTUFBTSxnQkFBZ0IsQ0FBQztBQUN4QixPQUFPLEVBQUUsYUFBYSxFQUFFLGFBQWEsRUFBRSxlQUFlLEVBQUUsY0FBYyxFQUFFLE1BQU0sb0JBQW9CLENBQUM7QUFFbkcsSUFBTSxRQUFRLEdBQUc7SUFDYixHQUFHLEVBQUUsQ0FBQztJQUNOLEdBQUcsRUFBRSxHQUFHO0lBQ1IsSUFBSSxFQUFFLE1BQU07SUFDWixLQUFLLEVBQUUsQ0FBQztJQUNSLGdCQUFnQixFQUFFLHNCQUFzQjtJQUN4QyxnQkFBZ0IsRUFBRSxvQkFBb0I7SUFDdEMsR0FBRyxFQUFFLE1BQU07SUFDWCxJQUFJLEVBQUUsR0FBRztDQUNaLENBQUM7QUFzQkY7SUEyRUksa0JBQW9CLFdBQXVCLEVBQVUsU0FBb0I7UUFBckQsZ0JBQVcsR0FBWCxXQUFXLENBQVk7UUFBVSxjQUFTLEdBQVQsU0FBUyxDQUFXO1FBaEVqRSxVQUFLLEdBQVcsUUFBUSxDQUFDLElBQUksQ0FBQztRQUM5QixTQUFJLEdBQVcsUUFBUSxDQUFDLEdBQUcsQ0FBQztRQUM1QixTQUFJLEdBQVcsUUFBUSxDQUFDLEdBQUcsQ0FBQztRQUM1QixhQUFRLEdBQVksSUFBSSxDQUFDO1FBRXpCLGlCQUFZLEdBQVksS0FBSyxDQUFDO1FBRTlCLHdCQUFtQixHQUFXLENBQUMsQ0FBQztR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RTtnQkFDRixNQUFNLEVBQUUsUUFBUTtnQkFDaEIsZUFBZSxFQUFFLE1BQU07Z0JBQ3ZCLHlCQUF5QixFQUFFLE1BQU07Z0JBQ2pDLHNCQUFzQixFQUFFLEtBQUs7Z0JBQzdCLHNCQUFzQixFQUFFLEtBQUs7Z0JBQzdCLHNCQUFzQixFQUFFLE9BQU87Z0JBQy9CLG1CQUFtQixFQUFFLFdBQVc7Z0JBQ2hDLHdCQUF3QixFQUFFLGdCQUFnQjthQUU3QztZQUNELGFBQWEsRUFBRSxpQkFBaUIsQ0FBQyxJQUFJOztTQUN4QyxDQUFDO3lDQTRFbUMsVUFBVSxFQUFxQixTQUFTO09BM0VoRSxRQUFRLENBNlFwQjtJQUFELGVBQUM7Q0FBQSxBQTdRRCxJQTZRQztTQTdRWSxRQUFRIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcclxuICAgIENvbXBvbmVudCxcclxuICAgIElucHV0LFxyXG4gICAgU2ltcGxlQ2hhbmdlcyxcclxuICAgIFZpZXdFbmNhcHN1bGF0aW9uLFxyXG4gICAgUmVuZGVyZXIyLFxyXG4gICAgQWZ0ZXJWaWV3SW5pdCxcclxuICAgIEVsZW1lbnRSZWYsXHJcbiAgICBPbkNoYW5nZXMsXHJcbiAgICBPbkRlc3Ryb3ksXHJcbiAgICBWaWV3Q2hpbGQsXHJcbiAgICBDb250ZW50Q2hpbGRcclxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuaW1wb3J0IHsgTmd4R2F1Z2VFcnJvciB9IGZyb20gJy4vZ2F1Z2UtZXJyb3InO1xyXG5pbXBvcnQge1xyXG4gICAgY2xhbXAsXHJcbiAgICBjb2VyY2VCb29sZWFuUHJvcGVydHksXHJcbiAgICBjb2VyY2VOdW1iZXJQcm9wZXJ0eSxcclxuICAgIGNzc1VuaXQsXHJcbiAgICBpc051bWJlclxyXG59IGZyb20gJy4uL2NvbW1vbi91dGlsJztcclxuaW1wb3J0IHsgTmd4R2F1Z2VMYWJlbCwgTmd4R2F1Z2VWYWx1ZSwgTmd4R2F1Z2VQcmVwZW5kLCBOZ3hHYXVnZUFwcGVuZCB9IGZyb20gJy4vZ2F1Z2UtZGlyZWN0aXZlcyc7XHJcblxyXG5jb25zdCBERUZBVUxUUyA9IHtcclxuICAgIE1JTjogMCxcclxuICAgIE1BWDogMTAwLFxyXG4gICAgVFlQRTogJ2FyY2gnLFxyXG4gICAgVEhJQ0s6IDQsXHJcbiAgICBGT1JFR1JPVU5EX0NPTE9SOiAncmdiYSgwLCAxNTAsIDEzNiwgMSknLFxyXG4gICAgQkFDS0dST1VORF9DT0xPUjogJ3JnYmEoMCwgMCwgMCwgMC4xKScsXHJcbiAgICBDQVA6ICdidXR0JyxcclxuICAgIFNJWkU6IDIwMFxyXG59O1xyXG5cclxuZXhwb3J0IHR5cGUgTmd4R2F1Z2VUeXBlID0gJ2Z1bGwnIHwgJ2FyY2gnIHwgJ3NlbWknO1xyXG5leHBvcnQgdHlwZSBOZ3hHYXVnZUNhcCA9ICdyb3VuZCcgfCAnYnV0dCc7XHJcblxyXG5AQ29tcG9uZW50KHtcclxuICAgIHNlbGVjdG9yOiAnbmd4LWdhdWdlJyxcclxuICAgIHRlbXBsYXRlVXJsOiAnZ2F1Z2UuaHRtbCcsXHJcbiAgICBzdHlsZVVybHM6IFsnZ2F1Z2UuY3NzJ10sXHJcbiAgICBob3N0OiB7XHJcbiAgICAgICAgJ3JvbGUnOiAnc2xpZGVyJyxcclxuICAgICAgICAnYXJpYS1yZWFkb25seSc6ICd0cnVlJyxcclxuICAgICAgICAnW2NsYXNzLm5neC1nYXVnZS1tZXRlcl0nOiAndHJ1ZScsXHJcbiAgICAgICAgJ1thdHRyLmFyaWEtdmFsdWVtaW5dJzogJ21pbicsXHJcbiAgICAgICAgJ1thdHRyLmFyaWEtdmFsdWVtYXhdJzogJ21heCcsXHJcbiAgICAgICAgJ1thdHRyLmFyaWEtdmFsdWVub3ddJzogJ3ZhbHVlJyxcclxuICAgICAgICAnW2F0dHIuYXJpYS1sYWJlbF0nOiAnYXJpYUxhYmVsJyxcclxuICAgICAgICAnW2F0dHIuYXJpYS1sYWJlbGxlZGJ5XSc6ICdhcmlhTGFiZWxsZWRieSdcclxuXHJcbiAgICB9LFxyXG4gICAgZW5jYXBzdWxhdGlvbjogVmlld0VuY2Fwc3VsYXRpb24uTm9uZVxyXG59KVxyXG5leHBvcnQgY2xhc3MgTmd4R2F1Z2UgaW1wbGVtZW50cyBBZnRlclZpZXdJbml0LCBPbkNoYW5nZXMsIE9uRGVzdHJveSB7XHJcblxyXG4gICAgQFZpZXdDaGlsZCgnY2FudmFzJywgeyBzdGF0aWM6IHRydWUgfSkgX2NhbnZhczogRWxlbWVudFJlZjtcclxuICAgIEBWaWV3Q2hpbGQoJ3JMYWJlbCcsIHsgc3RhdGljOiB0cnVlIH0pIF9sYWJlbDogRWxlbWVudFJlZjtcclxuICAgIEBWaWV3Q2hpbGQoJ3JlYWRpbmcnLCB7IHN0YXRpYzogdHJ1ZSB9KSBfcmVhZGluZzogRWxlbWVudFJlZjtcclxuXHJcbiAgICBAQ29udGVudENoaWxkKE5neEdhdWdlTGFiZWwpIF9sYWJlbENoaWxkOiBOZ3hHYXVnZUxhYmVsO1xyXG4gICAgQENvbnRlbnRDaGlsZChOZ3hHYXVnZVByZXBlbmQpIF9wcmVwZW5kQ2hpbGQ6IE5neEdhdWdlUHJlcGVuZDtcclxuICAgIEBDb250ZW50Q2hpbGQoTmd4R2F1Z2VBcHBlbmQpIF9hcHBlbmRDaGlsZDogTmd4R2F1Z2VBcHBlbmQ7XHJcbiAgICBAQ29udGVudENoaWxkKE5neEdhdWdlVmFsdWUpIF92YWx1ZURpc3BsYXlDaGlsZDogTmd4R2F1Z2VWYWx1ZTtcclxuXHJcbiAgICBwcml2YXRlIF9zaXplOiBudW1iZXIgPSBERUZBVUxUUy5TSVpFO1xyXG4gICAgcHJpdmF0ZSBfbWluOiBudW1iZXIgPSBERUZBVUxUUy5NSU47XHJcbiAgICBwcml2YXRlIF9tYXg6IG51bWJlciA9IERFRkFVTFRTLk1BWDtcclxuICAgIHByaXZhdGUgX2FuaW1hdGU6IGJvb2xlYW4gPSB0cnVlO1xyXG5cclxuICAgIHByaXZhdGUgX2luaXRpYWxpemVkOiBib29sZWFuID0gZmFsc2U7XHJcbiAgICBwcml2YXRlIF9jb250ZXh0OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQ7XHJcbiAgICBwcml2YXRlIF9hbmltYXRpb25SZXF1ZXN0SUQ6IG51bWJlciA9IDA7XHJcblxyXG4gICAgQElucHV0KCdhcmlhLWxhYmVsJykgYXJpYUxhYmVsOiBzdHJpbmcgPSAnJztcclxuXHJcbiAgICBASW5wdXQoJ2FyaWEtbGFiZWxsZWRieScpIGFyaWFMYWJlbGxlZGJ5OiBzdHJpbmcgfCBudWxsID0gbnVsbDtcclxuXHJcbiAgICBASW5wdXQoKVxyXG4gICAgZ2V0IHNpemUoKTogbnVtYmVyIHsgcmV0dXJuIHRoaXMuX3NpemU7IH1cclxuICAgIHNldCBzaXplKHZhbHVlOiBudW1iZXIpIHtcclxuICAgICAgICB0aGlzLl9zaXplID0gY29lcmNlTnVtYmVyUHJvcGVydHkodmFsdWUpO1xyXG4gICAgfVxyXG5cclxuICAgIEBJbnB1dCgpXHJcbiAgICBnZXQgbWluKCk6IG51bWJlciB7IHJldHVybiB0aGlzLl9taW47IH1cclxuICAgIHNldCBtaW4odmFsdWU6IG51bWJlcikge1xyXG4gICAgICAgIHRoaXMuX21pbiA9IGNvZXJjZU51bWJlclByb3BlcnR5KHZhbHVlLCBERUZBVUxUUy5NSU4pO1xyXG4gICAgfVxyXG4gICAgQElucHV0KClcclxuICAgIGdldCBhbmltYXRlKCk6IGJvb2xlYW4geyByZXR1cm4gdGhpcy5fYW5pbWF0ZTsgfVxyXG4gICAgc2V0IGFuaW1hdGUodmFsdWUpIHtcclxuICAgICAgICB0aGlzLl9hbmltYXRlID0gY29lcmNlQm9vbGVhblByb3BlcnR5KHZhbHVlKTtcclxuICAgIH1cclxuXHJcbiAgICBASW5wdXQoKVxyXG4gICAgZ2V0IG1heCgpOiBudW1iZXIgeyByZXR1cm4gdGhpcy5fbWF4OyB9XHJcbiAgICBzZXQgbWF4KHZhbHVlOiBudW1iZXIpIHtcclxuICAgICAgICB0aGlzLl9tYXggPSBjb2VyY2VOdW1iZXJQcm9wZXJ0eSh2YWx1ZSwgREVGQVVMVFMuTUFYKTtcclxuICAgIH1cclxuXHJcbiAgICBASW5wdXQoKSB0eXBlOiBOZ3hHYXVnZVR5cGUgPSBERUZBVUxUUy5UWVBFIGFzIE5neEdhdWdlVHlwZTtcclxuXHJcbiAgICBASW5wdXQoKSBjYXA6IE5neEdhdWdlQ2FwID0gREVGQVVMVFMuQ0FQIGFzIE5neEdhdWdlQ2FwO1xyXG5cclxuICAgIEBJbnB1dCgpIHRoaWNrOiBudW1iZXIgPSBERUZBVUxUUy5USElDSztcclxuXHJcbiAgICBASW5wdXQoKSBsYWJlbDogc3RyaW5nO1xyXG5cclxuICAgIEBJbnB1dCgpIGFwcGVuZDogc3RyaW5nO1xyXG5cclxuICAgIEBJbnB1dCgpIHByZXBlbmQ6IHN0cmluZztcclxuXHJcbiAgICBASW5wdXQoKSBmb3JlZ3JvdW5kQ29sb3I6IHN0cmluZyA9IERFRkFVTFRTLkZPUkVHUk9VTkRfQ09MT1I7XHJcblxyXG4gICAgQElucHV0KCkgYmFja2dyb3VuZENvbG9yOiBzdHJpbmcgPSBERUZBVUxUUy5CQUNLR1JPVU5EX0NPTE9SO1xyXG5cclxuICAgIEBJbnB1dCgpIHRocmVzaG9sZHM6IE9iamVjdCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XHJcblxyXG4gICAgcHJpdmF0ZSBfdmFsdWU6IG51bWJlciA9IDA7XHJcblxyXG4gICAgQElucHV0KClcclxuICAgIGdldCB2YWx1ZSgpIHsgcmV0dXJuIHRoaXMuX3ZhbHVlOyB9XHJcbiAgICBzZXQgdmFsdWUodmFsOiBudW1iZXIpIHtcclxuICAgICAgICB0aGlzLl92YWx1ZSA9IGNvZXJjZU51bWJlclByb3BlcnR5KHZhbCk7XHJcbiAgICB9XHJcblxyXG4gICAgQElucHV0KCkgZHVyYXRpb246IG51bWJlciA9IDEyMDA7XHJcblxyXG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSBfZWxlbWVudFJlZjogRWxlbWVudFJlZiwgcHJpdmF0ZSBfcmVuZGVyZXI6IFJlbmRlcmVyMikgeyB9XHJcblxyXG4gICAgbmdPbkNoYW5nZXMoY2hhbmdlczogU2ltcGxlQ2hhbmdlcykge1xyXG4gICAgICAgIGNvbnN0IGlzQ2FudmFzUHJvcGVydHlDaGFuZ2VkID0gY2hhbmdlc1sndGhpY2snXSB8fCBjaGFuZ2VzWyd0eXBlJ10gfHwgY2hhbmdlc1snY2FwJ10gfHwgY2hhbmdlc1snc2l6ZSddO1xyXG4gICAgICAgIGNvbnN0IGlzRGF0YUNoYW5nZWQgPSBjaGFuZ2VzWyd2YWx1ZSddIHx8IGNoYW5nZXNbJ21pbiddIHx8IGNoYW5nZXNbJ21heCddO1xyXG5cclxuICAgICAgICBpZiAodGhpcy5faW5pdGlhbGl6ZWQpIHtcclxuICAgICAgICAgICAgaWYgKGlzRGF0YUNoYW5nZWQpIHtcclxuICAgICAgICAgICAgICAgIGxldCBudiwgb3Y7XHJcbiAgICAgICAgICAgICAgICBpZiAoY2hhbmdlc1sndmFsdWUnXSkge1xyXG4gICAgICAgICAgICAgICAgICAgIG52ID0gY2hhbmdlc1sndmFsdWUnXS5jdXJyZW50VmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgb3YgPSBjaGFuZ2VzWyd2YWx1ZSddLnByZXZpb3VzVmFsdWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLl91cGRhdGUobnYsIG92KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoaXNDYW52YXNQcm9wZXJ0eUNoYW5nZWQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2Rlc3Ryb3koKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2luaXQoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIF91cGRhdGVTaXplKCkge1xyXG4gICAgICAgIHRoaXMuX3JlbmRlcmVyLnNldFN0eWxlKHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudCwgJ3dpZHRoJywgY3NzVW5pdCh0aGlzLl9nZXRXaWR0aCgpKSk7XHJcbiAgICAgICAgdGhpcy5fcmVuZGVyZXIuc2V0U3R5bGUodGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LCAnaGVpZ2h0JywgY3NzVW5pdCh0aGlzLl9nZXRDYW52YXNIZWlnaHQoKSkpO1xyXG4gICAgICAgIHRoaXMuX2NhbnZhcy5uYXRpdmVFbGVtZW50LndpZHRoID0gdGhpcy5fZ2V0V2lkdGgoKTtcclxuICAgICAgICB0aGlzLl9jYW52YXMubmF0aXZlRWxlbWVudC5oZWlnaHQgPSB0aGlzLl9nZXRDYW52YXNIZWlnaHQoKTtcclxuICAgICAgICB0aGlzLl9yZW5kZXJlci5zZXRTdHlsZSh0aGlzLl9sYWJlbC5uYXRpdmVFbGVtZW50LFxyXG4gICAgICAgICAgICAndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZVkoJyArICh0aGlzLnNpemUgLyAzICogMiAtIHRoaXMuc2l6ZSAvIDEzIC8gNCkgKyAncHgpJyk7XHJcbiAgICAgICAgdGhpcy5fcmVuZGVyZXIuc2V0U3R5bGUodGhpcy5fcmVhZGluZy5uYXRpdmVFbGVtZW50LFxyXG4gICAgICAgICAgICAndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZVkoJyArICh0aGlzLnNpemUgLyAyIC0gdGhpcy5zaXplICogMC4yMiAvIDIpICsgJ3B4KScpO1xyXG4gICAgfVxyXG5cclxuICAgIG5nQWZ0ZXJWaWV3SW5pdCgpIHtcclxuICAgICAgICBpZiAodGhpcy5fY2FudmFzKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2luaXQoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgbmdPbkRlc3Ryb3koKSB7XHJcbiAgICAgICAgdGhpcy5fZGVzdHJveSgpO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgX2dldEJvdW5kcyh0eXBlOiBOZ3hHYXVnZVR5cGUpIHtcclxuICAgICAgICBsZXQgaGVhZCwgdGFpbDtcclxuICAgICAgICBpZiAodHlwZSA9PSAnc2VtaScpIHtcclxuICAgICAgICAgICAgaGVhZCA9IE1hdGguUEk7XHJcbiAgICAgICAgICAgIHRhaWwgPSAyICogTWF0aC5QSTtcclxuICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT0gJ2Z1bGwnKSB7XHJcbiAgICAgICAgICAgIGhlYWQgPSAxLjUgKiBNYXRoLlBJO1xyXG4gICAgICAgICAgICB0YWlsID0gMy41ICogTWF0aC5QSTtcclxuICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdhcmNoJykge1xyXG4gICAgICAgICAgICBoZWFkID0gMC44ICogTWF0aC5QSTtcclxuICAgICAgICAgICAgdGFpbCA9IDIuMiAqIE1hdGguUEk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB7IGhlYWQsIHRhaWwgfTtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIF9kcmF3U2hlbGwoc3RhcnQ6IG51bWJlciwgbWlkZGxlOiBudW1iZXIsIHRhaWw6IG51bWJlciwgY29sb3I6IHN0cmluZykge1xyXG4gICAgICAgIGxldCBjZW50ZXIgPSB0aGlzLl9nZXRDZW50ZXIoKSxcclxuICAgICAgICAgICAgcmFkaXVzID0gdGhpcy5fZ2V0UmFkaXVzKCk7XHJcblxyXG4gICAgICAgIG1pZGRsZSA9IE1hdGgubWF4KG1pZGRsZSwgc3RhcnQpOyAvLyBuZXZlciBiZWxvdyAwJVxyXG4gICAgICAgIG1pZGRsZSA9IE1hdGgubWluKG1pZGRsZSwgdGFpbCk7IC8vIG5ldmVyIGV4Y2VlZCAxMDAlXHJcbiAgICAgICAgaWYgKHRoaXMuX2luaXRpYWxpemVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2NsZWFyKCk7XHJcbiAgICAgICAgICAgIHRoaXMuX2NvbnRleHQuYmVnaW5QYXRoKCk7XHJcbiAgICAgICAgICAgIHRoaXMuX2NvbnRleHQuc3Ryb2tlU3R5bGUgPSB0aGlzLmJhY2tncm91bmRDb2xvcjtcclxuICAgICAgICAgICAgdGhpcy5fY29udGV4dC5hcmMoY2VudGVyLngsIGNlbnRlci55LCByYWRpdXMsIG1pZGRsZSwgdGFpbCwgZmFsc2UpO1xyXG4gICAgICAgICAgICB0aGlzLl9jb250ZXh0LnN0cm9rZSgpO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5fY29udGV4dC5iZWdpblBhdGgoKTtcclxuICAgICAgICAgICAgdGhpcy5fY29udGV4dC5zdHJva2VTdHlsZSA9IGNvbG9yO1xyXG4gICAgICAgICAgICB0aGlzLl9jb250ZXh0LmFyYyhjZW50ZXIueCwgY2VudGVyLnksIHJhZGl1cywgc3RhcnQsIG1pZGRsZSwgZmFsc2UpO1xyXG4gICAgICAgICAgICB0aGlzLl9jb250ZXh0LnN0cm9rZSgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIF9jbGVhcigpIHtcclxuICAgICAgICB0aGlzLl9jb250ZXh0LmNsZWFyUmVjdCgwLCAwLCB0aGlzLl9nZXRXaWR0aCgpLCB0aGlzLl9nZXRIZWlnaHQoKSk7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBfZ2V0V2lkdGgoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc2l6ZTtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIF9nZXRIZWlnaHQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc2l6ZTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBjYW52YXMgaGVpZ2h0IHdpbGwgYmUgc2hvcnRlciBmb3IgdHlwZSAnc2VtaScgYW5kICdhcmNoJ1xyXG4gICAgcHJpdmF0ZSBfZ2V0Q2FudmFzSGVpZ2h0KCkge1xyXG4gICAgICAgIHJldHVybiAodGhpcy50eXBlID09ICdhcmNoJyB8fCB0aGlzLnR5cGUgPT0gJ3NlbWknKVxyXG4gICAgICAgICAgICA/IDAuODUgKiB0aGlzLl9nZXRIZWlnaHQoKVxyXG4gICAgICAgICAgICA6IHRoaXMuX2dldEhlaWdodCgpO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgX2dldFJhZGl1cygpIHtcclxuICAgICAgICB2YXIgY2VudGVyID0gdGhpcy5fZ2V0Q2VudGVyKCk7XHJcbiAgICAgICAgcmV0dXJuIGNlbnRlci54IC0gdGhpcy50aGljaztcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIF9nZXRDZW50ZXIoKSB7XHJcbiAgICAgICAgdmFyIHggPSB0aGlzLl9nZXRXaWR0aCgpIC8gMixcclxuICAgICAgICAgICAgeSA9IHRoaXMuX2dldEhlaWdodCgpIC8gMjtcclxuICAgICAgICByZXR1cm4geyB4LCB5IH07XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBfaW5pdCgpIHtcclxuICAgICAgICB0aGlzLl9jb250ZXh0ID0gKHRoaXMuX2NhbnZhcy5uYXRpdmVFbGVtZW50IGFzIEhUTUxDYW52YXNFbGVtZW50KS5nZXRDb250ZXh0KCcyZCcpO1xyXG4gICAgICAgIHRoaXMuX2luaXRpYWxpemVkID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLl91cGRhdGVTaXplKCk7XHJcbiAgICAgICAgdGhpcy5fc2V0dXBTdHlsZXMoKTtcclxuICAgICAgICB0aGlzLl9jcmVhdGUoKTtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIF9kZXN0cm95KCkge1xyXG4gICAgICAgIGlmICh0aGlzLl9hbmltYXRpb25SZXF1ZXN0SUQpIHtcclxuICAgICAgICAgICAgd2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMuX2FuaW1hdGlvblJlcXVlc3RJRCk7XHJcbiAgICAgICAgICAgIHRoaXMuX2FuaW1hdGlvblJlcXVlc3RJRCA9IDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX2NsZWFyKCk7XHJcbiAgICAgICAgdGhpcy5fY29udGV4dCA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5faW5pdGlhbGl6ZWQgPSBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIF9zZXR1cFN0eWxlcygpIHtcclxuICAgICAgICB0aGlzLl9jb250ZXh0LmxpbmVDYXAgPSB0aGlzLmNhcDtcclxuICAgICAgICB0aGlzLl9jb250ZXh0LmxpbmVXaWR0aCA9IHRoaXMudGhpY2s7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBfZ2V0Rm9yZWdyb3VuZENvbG9yQnlSYW5nZSh2YWx1ZSkge1xyXG5cclxuICAgICAgICBjb25zdCBtYXRjaCA9IE9iamVjdC5rZXlzKHRoaXMudGhyZXNob2xkcylcclxuICAgICAgICAgICAgLmZpbHRlcihmdW5jdGlvbiAoaXRlbSkgeyByZXR1cm4gaXNOdW1iZXIoaXRlbSkgJiYgTnVtYmVyKGl0ZW0pIDw9IHZhbHVlIH0pXHJcbiAgICAgICAgICAgIC5zb3J0KChhLCBiKSA9PiBOdW1iZXIoYSkgLSBOdW1iZXIoYikpXHJcbiAgICAgICAgICAgIC5yZXZlcnNlKClbMF07XHJcblxyXG4gICAgICAgIHJldHVybiBtYXRjaCAhPT0gdW5kZWZpbmVkXHJcbiAgICAgICAgICAgID8gdGhpcy50aHJlc2hvbGRzW21hdGNoXS5jb2xvciB8fCB0aGlzLmZvcmVncm91bmRDb2xvclxyXG4gICAgICAgICAgICA6IHRoaXMuZm9yZWdyb3VuZENvbG9yO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgX2NyZWF0ZShudj86IG51bWJlciwgb3Y/OiBudW1iZXIpIHtcclxuICAgICAgICBsZXQgc2VsZiA9IHRoaXMsXHJcbiAgICAgICAgICAgIHR5cGUgPSB0aGlzLnR5cGUsXHJcbiAgICAgICAgICAgIGJvdW5kcyA9IHRoaXMuX2dldEJvdW5kcyh0eXBlKSxcclxuICAgICAgICAgICAgZHVyYXRpb24gPSB0aGlzLmR1cmF0aW9uLFxyXG4gICAgICAgICAgICBtaW4gPSB0aGlzLm1pbixcclxuICAgICAgICAgICAgbWF4ID0gdGhpcy5tYXgsXHJcbiAgICAgICAgICAgIHZhbHVlID0gY2xhbXAodGhpcy52YWx1ZSwgdGhpcy5taW4sIHRoaXMubWF4KSxcclxuICAgICAgICAgICAgc3RhcnQgPSBib3VuZHMuaGVhZCxcclxuICAgICAgICAgICAgdW5pdCA9IChib3VuZHMudGFpbCAtIGJvdW5kcy5oZWFkKSAvIChtYXggLSBtaW4pLFxyXG4gICAgICAgICAgICBkaXNwbGFjZW1lbnQgPSB1bml0ICogKHZhbHVlIC0gbWluKSxcclxuICAgICAgICAgICAgdGFpbCA9IGJvdW5kcy50YWlsLFxyXG4gICAgICAgICAgICBjb2xvciA9IHRoaXMuX2dldEZvcmVncm91bmRDb2xvckJ5UmFuZ2UodmFsdWUpLFxyXG4gICAgICAgICAgICBzdGFydFRpbWU7XHJcblxyXG4gICAgICAgIGlmIChzZWxmLl9hbmltYXRpb25SZXF1ZXN0SUQpIHtcclxuICAgICAgICAgICAgd2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lKHNlbGYuX2FuaW1hdGlvblJlcXVlc3RJRCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmdW5jdGlvbiBhbmltYXRlKHRpbWVzdGFtcCkge1xyXG4gICAgICAgICAgICB0aW1lc3RhbXAgPSB0aW1lc3RhbXAgfHwgbmV3IERhdGUoKS5nZXRUaW1lKCk7XHJcbiAgICAgICAgICAgIGxldCBydW50aW1lID0gdGltZXN0YW1wIC0gc3RhcnRUaW1lO1xyXG4gICAgICAgICAgICBsZXQgcHJvZ3Jlc3MgPSBNYXRoLm1pbihydW50aW1lIC8gZHVyYXRpb24sIDEpO1xyXG4gICAgICAgICAgICBsZXQgcHJldmlvdXNQcm9ncmVzcyA9IG92ID8gKG92IC0gbWluKSAqIHVuaXQgOiAwO1xyXG4gICAgICAgICAgICBsZXQgbWlkZGxlID0gc3RhcnQgKyBwcmV2aW91c1Byb2dyZXNzICsgZGlzcGxhY2VtZW50ICogcHJvZ3Jlc3M7XHJcblxyXG4gICAgICAgICAgICBzZWxmLl9kcmF3U2hlbGwoc3RhcnQsIG1pZGRsZSwgdGFpbCwgY29sb3IpO1xyXG4gICAgICAgICAgICBpZiAoc2VsZi5fYW5pbWF0aW9uUmVxdWVzdElEICYmIChydW50aW1lIDwgZHVyYXRpb24pKSB7XHJcbiAgICAgICAgICAgICAgICBzZWxmLl9hbmltYXRpb25SZXF1ZXN0SUQgPSB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKCh0aW1lc3RhbXApID0+IGFuaW1hdGUodGltZXN0YW1wKSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWUoc2VsZi5fYW5pbWF0aW9uUmVxdWVzdElEKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5fYW5pbWF0ZSkge1xyXG4gICAgICAgICAgICBpZiAobnYgIT0gdW5kZWZpbmVkICYmIG92ICE9IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgZGlzcGxhY2VtZW50ID0gdW5pdCAqIG52IC0gdW5pdCAqIG92O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHNlbGYuX2FuaW1hdGlvblJlcXVlc3RJRCA9IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKHRpbWVzdGFtcCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgc3RhcnRUaW1lID0gdGltZXN0YW1wIHx8IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xyXG4gICAgICAgICAgICAgICAgYW5pbWF0ZShzdGFydFRpbWUpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBzZWxmLl9kcmF3U2hlbGwoc3RhcnQsIHN0YXJ0ICsgZGlzcGxhY2VtZW50LCB0YWlsLCBjb2xvcik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgX3VwZGF0ZShudjogbnVtYmVyLCBvdjogbnVtYmVyKSB7XHJcbiAgICAgICAgdGhpcy5fY2xlYXIoKTtcclxuICAgICAgICB0aGlzLl9jcmVhdGUobnYsIG92KTtcclxuICAgIH1cclxuXHJcbn1cclxuIl19